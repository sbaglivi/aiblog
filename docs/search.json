[
  {
    "objectID": "notebooks/interactive_plot.html",
    "href": "notebooks/interactive_plot.html",
    "title": "",
    "section": "",
    "text": "import matplotlib\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport torch\n\n\ndef q(a,b,c,x): return a*x**2 + b*x + c\n\n\nfrom functools import partial\n\n\ndef plot_function(f):\n    x = np.linspace(-10, 10, 50)\n    y = f(x)\n    plt.plot(x, y)\n\n\ntime = torch.tensor(np.linspace(0, 20, 20))\nf = partial(q, 1, -2, 0)\ny = f(time)\nnoise = 5 * torch.randn((len(time),))\nspeed = (noise + y).max(torch.tensor(0.0))\nspeed[0] = 0.0\n\n\nfig, ax = plt.subplots()\nline, = ax.plot(time, speed)\nax.set_xlabel('time')\nax.set_ylabel('speed')\nax.set_title('Speed over time')\n\nText(0.5, 1.0, 'Speed over time')\n\n\n\n\n\n\n\n\n\n\nplt.rc('figure', dpi=90)\n\ndef plot_function(f, title=None, min=-2.1, max=2.1, color='r', ylim=None):\n    x = torch.linspace(min,max, 100)[:,None]\n    if ylim: plt.ylim(ylim)\n    plt.plot(x, f(x), color)\n    if title is not None: plt.title(title)\n\n\ndef noise(x, scale): return np.random.normal(scale=scale, size=x.shape)\ndef add_noise(x, mult, add): return x * (1+noise(x,mult)) + noise(x,add)\n\n\ndef f(x): return 3*x**2 + 2*x + 1\nx = torch.linspace(-2, 2, steps=20)[:,None]\ny = add_noise(f(x), 0.15, 1.5)\n\n\nfrom ipywidgets import *\n\n\n@interact(a=1.1, b=1.1, c=1.1)\ndef plot_quad(a, b, c):\n    plt.scatter(x,y)\n    plot_function(partial(q, a,b,c), ylim=(-3,13))\n\n\n\n\n\ndef mse(pred, labels, item=True):\n    se = ((pred - labels)**2).mean()\n    return se.item() if item else se\n\n\nf = partial(q, 1, 1, 1)\nsqe = (f(x) - y)**2\n\n\n((f(x)-y)**2).mean()\n\ntensor(13.6295, dtype=torch.float64)\n\n\n\n@interact(a=1.1, b=1.1, c=1.1)\ndef plot_quad(a, b, c):\n    plt.scatter(x,y)\n    f = partial(q, a,b,c)\n    plot_function(f, ylim=(-3,13), title=mse(f(x), y))\n\n\n\n\n\n# weights = torch.randn(3).requires_grad_()\nweights = torch.tensor([2.6, 1.5, 1.2]).requires_grad_()\ndef f(w, x): return x**2*w[0] + x*w[1] + w[2]\n\n\nf(weights, 5)\n\ntensor(78.5000, grad_fn=&lt;AddBackward0&gt;)\n\n\n\nfor i in range(1000):\n    preds = f(weights, x)\n    loss = mse(preds, y, item=False)\n    loss.backward()\n    with torch.no_grad():\n        weights -= 0.0001 * weights.grad\n    weights.grad = None\n    if i % 100 == 0:\n        print(i, loss.item())\n\n0 1.9257010423639997\n100 1.9257007564709832\n200 1.9257003216835447\n300 1.9256999705553355\n400 1.9256991464339133\n500 1.9256988260907906\n600 1.9256983210555796\n700 1.925698083525107\n800 1.9256977687568035\n900 1.925697447561204\n\n\n\nwith torch.no_grad():\n    plt.scatter(x, y)\n\n    plot_function(partial(q, *list(weights)))\n    plot_function(partial(q, 2.6, 1.5, 1.2), color='b')\n    print(weights)\n\ntensor([2.6524, 1.4740, 1.1451], requires_grad=True)"
  }
]